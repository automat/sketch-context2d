@import AppKit;

//TODO: Fix state getter setter, fix conversion to webscriptobject

//Bindings to CanvasRenderingContext2D,
//except:
//
//// hit regions
//void addHitRegion(HitRegionOptions options);
//void removeHitRegion(DOMString id);
//void clearHitRegions();
//
//// pixel manipulation
//ImageData createImageData(unrestricted double sw, unrestricted double sh);
//ImageData createImageData(ImageData imagedata);
//ImageData getImageData(double sx, double sy, double sw, double sh);
//void putImageData(ImageData imagedata, double dx, double dy);
//void putImageData(ImageData imagedata, double dx, double dy, double dirtyX, double dirtyY, double dirtyWidth, double dirtyHeight);};

function Context2DBindings(group){
    var path  = null;
    var layer = null;

    var state = {
        fillStyle :   'black',
        strokeStyle : 'black',
        transform : NSAffineTransform.new(),
        globalAlpha : 1.0,
        //shadows
        shadowOffsetX : 0.0,
        shadowOffsetY : 0.0,
        shadowBlur    : 0.0,
        shadowColor   : "transparent black",
        //line caps / joins
        lineWidth : 1.0,
        lineCap : 'butt',
        lineJoin : 'round',
        miterLimit : '10',
        lineDash : [],
        lineDashOffset : 0,
        //text,
        font : '10px sans-serif',
        textAlign : 'start',
        textBaseline: 'alphabetic'

    };

    var stack = [state];

    var style = null;
    var stylePartStroke = {ref : null, valid : false, dirty : false};
    var stylePartFill   = {ref : null, valid : false, dirty : false};

    var pathAdded      = false;
    var pathDirty      = false;
    var transformDirty = false;

    var isClipping = false;

    function parseColor(val){
        val = toString(val);
        if(val == ''){
            return null;
        }
        return val;
    }

    function setStatePropertyWithStylePart(stateKey,value,stylePart){
        if(value == state[stateKey]){
            return;
        }
        stylePart.dirty = true;
        if(value == null){
            stylePart.valid = false;
            state[stateKey] = null;
            return;
        }
        stylePart.valid = true;
        state[stateKey] = value;

    }

    function addPathWithStylePart(stroke,fill){
        //1 element + valid segments
        if(path.elementCount() < 1 || !pathDirty){
            return;
        }

        path.transformUsingAffineTransform_(state.transform);

        if(!layer){
            layer = MSShapeGroup.shapeWithBezierPath(path);
            layer.setStyle_(style);
            group.addLayers([layer]);
        }

        // valid stroke
        if(stroke && stylePartStroke.valid){
            var needsUpdate = !stylePartStroke.ref || stylePartStroke.dirty;
            //add stroke part
            if(!stylePartStroke.ref){
                stylePartStroke.ref = style.borders().addNewStylePart();
            }
            //update stroke part
            if(needsUpdate){
                var ref = stylePartStroke.ref;

                //FIXME
                switch(state.lineCap){
                    case 'butt':
                        path.lineCapStyle = NSButtLineCapStyle;
                        break;
                    case 'round':
                        path.lineCapStyle = NSRoundLineCapStyle;
                        break;
                    case 'square':
                        path.lineCapStyle = NSSquareLineCapStyle;
                        break;
                }

                //FIXME
                switch(state.lineJoin){
                    case 'miter':
                        path.lineJoinStyle = NSMiterLineJoinStyle;
                        break;
                    case 'round':
                        path.lineJoinStyle = NSRoundLineJoinStyle;
                        break;
                    case 'bevel':
                        path.lineJoinStyle = NSBevelLineJoinStyle;
                        break;
                }

                ref.thickness = state.lineWidth;
                ref.color     = MSColor.colorWithSVGString(state.strokeStyle);
            }
            stylePartStroke.dirty = false;
            // invalid stroke / none
        } else {
            if(stylePartStroke.ref){
                style.strokes().removeStylePart_(stylePartStroke.ref);
                stylePartStroke.ref = null;
            }
        }

        // valid fill
        if(fill && stylePartFill.valid){
            var needsUpdate = !stylePartFill.ref || stylePartFill.dirty;
            //add fill part
            if(!stylePartFill.ref){
                stylePartFill.ref = style.fills().addNewStylePart();
            }
            //update fill part
            if(needsUpdate){
                var ref = stylePartFill.ref;
                ref.color = MSColor.colorWithSVGString(state.fillStyle);
            }
            stylePartFill.dirty = false;
            // invalid fill / none
        } else {
            if(stylePartFill.ref){
                style.fills().removeStylePart_(stylePartFill.ref);
                stylePartFill.ref = null;
            }
        }

        //TODO: Fix group resizing, this offsets paths
        //group.resizeToFitChildrenWithOption(0);
    }

    function toString(val){
        return !val ? '' : ('' + val);
    }

    function toNumber(val){
        return +val || 0;
    }

    function toNumberSafe(val){
        return val.JSValue().toNumber() || 0;
    }

    function toBoolean(val){
        return !!(+val);
    }

    function toDegrees(radians){
        return radians * 180 / Math.PI;
    }

    function appendRect(x,y,width,height){
        x = toNumber(x);
        y = toNumber(y);
        width  = toNumber(width);
        height = toNumber(height);

        path.appendBezierPathWithRect_(
            NSMakeRect(x,y,width,height)
        );
    }

    function setTransform(transform,m11,m12,m21,m22,tx,ty){
        var transformStruct = transform.transformStruct;
        transformStruct.m11 = m11;
        transformStruct.m12 = m12;
        transformStruct.m21 = m21;
        transformStruct.m22 = m22;
        transformStruct.tX = tx;
        transformStruct.tY = ty;
    }

    function beginPath(){
        path  = NSBezierPath.bezierPath();
        layer = null;

        //reset style
        style = MSStyle.alloc().init();
        //reset style parts
        stylePartStroke.ref   = null;
        stylePartStroke.dirty = false;
        stylePartFill.ref   = null;
        stylePartFill.dirty = false;

        pathAdded = false;
        pathDirty = false;
    }

    var ctx = {
        /*------------------------------------------------------------------------------------------------------------*/
        // test
        /*------------------------------------------------------------------------------------------------------------*/
        testMethod1 : function(a){
            print(a);
        },
        testMethod2 : function(a,b){
            print(a);
            print(b);
        },
        testMethod3 : function(a,b,c){
            print(a);
            print(b);
            print(c);
        },
        testMethod4 : function(a,b,c,d){
            print(a);
            print(b);
            print(c);
            print(d);
        },
        /*------------------------------------------------------------------------------------------------------------*/
        // state
        /*------------------------------------------------------------------------------------------------------------*/
        // push state on state stack
        save : function(){
            stack.push({
                fillStyle   : state.fillStyle,
                strokeStyle : state.strokeStyle,
                globalAlpha : state.globalAlpha,
                transform :  transform.new().initWithTransform_(state.transform),
                //line caps / joins
                lineWidth  : state.lineWidth,
                lineCap    : state.lineCap,
                lineJoin   : state.lineJoin,
                miterLimit : state.miterLimit
            });
        },
        // pop state stack and restore state
        restore : function(){
            var prevState = stack[stack.length-1];

            for(var key in prevState){
                switch(key){
                    case 'transform':
                        var transformStruct = state.transform.transformStruct;
                        var m11 = transformStruct.m11;
                        var m12 = transformStruct.m12;
                        var m21 = transformStruct.m21;
                        var m22 = transformStruct.m22;
                        var tX  = transformStruct.tX;
                        var tY  = transformStruct.tY;
                        this.setTransform(m11,m12,m21,m22,tX,tY);
                        break;

                    default:
                        var setter = 'set' + key.charAt(0).toUpperCase() + key.substr(1);
                        this[setter](prevState[key]);
                        break;
                }
            }
            stack.pop();
        },

        /*------------------------------------------------------------------------------------------------------------*/
        // transformations (default: transform is the identity matrix)
        /*------------------------------------------------------------------------------------------------------------*/

        scale : function(x,y){
            x = toNumber(x);
            y = toNumber(y);
            state.transform.scaleXBy_yBy_(x,y);
            transformDirty = true;
        },
        rotate : function(angle){
            angle = toNumber(angle);
            state.transform.rotateByRadians_(angle);
            transformDirty = true;
        },
        translate : function(x,y){
            x = toNumber(x);
            y = toNumber(y);
            state.transform.translateXBy_yBy_(x,y);
            transformDirty = true;
        },
        transform : function(args){
            var m11 = toNumber(args[0]);
            var m12 = toNumber(args[1]);
            var m21 = toNumber(args[2]);
            var m22 = toNumber(args[3]);
            var tX = toNumber(args[4]);
            var tY = toNumber(args[5]);

            var transform_ = NSAffineTransform.new();
            setTransform(transform_,m11,m12,m21,m22,tX,tY);
            state.transform.appendTransform_(transform_);
            transformDirty = true;
        },
        setTransform : function(args){
            var m11 = toNumber(args[0]);
            var m12 = toNumber(args[1]);
            var m21 = toNumber(args[2]);
            var m22 = toNumber(args[3]);
            var tX = toNumber(args[4]);
            var tY = toNumber(args[5]);

            setTransform(state.transform,m11,m12,m21,m22,tX,tY);
            transformDirty = true;
        },

        /*------------------------------------------------------------------------------------------------------------*/
        // compositing
        /*------------------------------------------------------------------------------------------------------------*/
        // (default: 1.0)
        setGlobalAlpha : function(args){
            var alpha = toNumber(args[0]);
            state.globalAlpha = alpha;
        },
        getGlobalAlpha : function(){
            return state.globalAlpha;
        },
        // (default: "source-over")
        setGlobalCompositeOperation : function(args){
            var val = toString(args[0]);
            stack.globalCompositeOperation = val;
        },
        getGlobalCompositeOperation : function(){
            return state.globalCompositeOperation;
        },

        /*------------------------------------------------------------------------------------------------------------*/
        // colors and styles
        /*------------------------------------------------------------------------------------------------------------*/
        // (default: "black")
        setStrokeStyle : function(color){
            color = parseColor(color);
            setStatePropertyWithStylePart('strokeStyle', color, stylePartStroke);
        },
        // (default: "black")
        getStrokeStyle : function(){
            return state.strokeStyle;
        },
        setFillStyle : function(color){
            color = parseColor(color);
            setStatePropertyWithStylePart('fillStyle', color, stylePartFill);
        },
        getFillStyle : function(){
            return state.fillStyle;
        },
        createLinearGradient : function(args){
            //TODO: Add createLinearGradient
        },
        createRadialGradient : function(args){
            //TODO: Add createRadialGradient
        },
        createPattern : function(){
            //TODO: Add createPattern
        },
        addColorStop : function(){
            //TODO: Add addColorStop
        },

        /*------------------------------------------------------------------------------------------------------------*/
        // line caps / joins
        /*------------------------------------------------------------------------------------------------------------*/

        setLineWidth : function(lineWidth){
            lineWidth = toNumber(lineWidth);
            setStatePropertyWithStylePart('lineWidth', val, stylePartStroke);
        },
        getLineWidth : function(){
            return state.lineWidth;
        },
        setLineCap : function(lineCap){
            lineCap = toString(lineCap);
            switch(lineCap){
                case 'round' :
                case 'square' :
                    setStatePropertyWithStylePart('lineCap', lineCap, stylePartStroke);
                    break;
                default:
                    setStatePropertyWithStylePart('lineCap', 'butt', stylePartStroke);
                    break;
            }
        },
        getLineCap : function(){
            return state.lineCap;
        },
        setLineJoin : function(lineJoin){
            lineJoin = toString(lineJoin);
            switch(lineJoin){
                case 'round':
                case 'bevel':
                    setStatePropertyWithStylePart('lineJoin', lineJoin, stylePartStroke);
                    break;
                default:
                    setStatePropertyWithStylePart('lineJoin', 'miter', stylePartStroke);
                    break;
            }
        },
        getLineJoin : function(){
            return stack.lineJoin;
        },
        setMiterLimit : function(miterLimit){
            miterLimit = toNumber(miterLimit);
            setStatePropertyWithStylePart('miterLimit', miterLimit, stylePartStroke);
        },
        getMiterLimit : function(){
            return state.miterLimit;
        },
        setLineDash : function(dash){
            var length = dash.count() || dash.length || 0;
            state.lineDash.length = length;
            for(var i = 0; i < length; ++i){
                state.lineDash[i] = dash[i];
            }
        },
        getLineDash : function(){
            return state.lineDash.slice(0);
        },
        setLineDashOffset : function(offset){
            offset = toNumber(offset);
            setStatePropertyWithStylePart('lineDashOffset',offset,stylePartStroke);
        },
        getLineDashOffset : function(){
            return state.lineDashOfffset;
        },

        /*------------------------------------------------------------------------------------------------------------*/
        // shadows
        /*------------------------------------------------------------------------------------------------------------*/

        setShadowOffsetX : function(offset){
            offset = toNumber(offset);
            setStatePropertyWithStylePart('shadowOffsetX',offset,stylePartStroke);
        },
        getShadowOffsetX : function(){
            return state.shadowOffsetX;
        },
        setShadowOffsetY : function(offset){
            offset = toNumber(offset);
            setStatePropertyWithStylePart('shadowOffsetY',offset,stylePartStroke);
        },
        getShadowOffsetY : function(){
            return state.shadowOffsetY
        },
        setShadowColor : function(color){
            color = parseColor(color);
            setStatePropertyWithStylePart('shadowColor',color,stylePartStroke);
        },
        getShadowColor : function(){
            return state.shadowColor;
        },
        setShadowBlur : function(blur){
            blur = toNumber(blur);
            setStatePropertyWithStylePart('shadowBlur',blur,stylePartStroke);
        },
        getShadowBlur : function(){
            return state.shadowBlur;
        },

        /*------------------------------------------------------------------------------------------------------------*/
        // path API
        /*------------------------------------------------------------------------------------------------------------*/

        beginPath : beginPath,
        closePath : function(){
            if(!path){
                return;
            }
            path.closePath();
        },
        moveTo : function(x,y){
            if(!path){
                return;
            }
            x = toNumber(x);
            y = toNumber(y);
            path.moveToPoint(NSMakePoint(x,y));
        },
        lineTo : function(x,y){
            if(!path){
                return;
            }
            x = toNumber(x);
            y = toNumber(y);
            path.lineToPoint_(NSMakePoint(x,y));
            pathDirty = true;
        },
        quadraticCurveTo : function(cpx,cpy,x,y){
            if(!path){
                return;
            }
            cpx = toNumber(cpx);
            cpy = toNumber(cpy);
            x = toNumber(x);
            y = toNumber(y);
            var cp = NSMakePoint(cpx,cpy);

            path.curveToPoint_(
                NSMakePoint(x,y),
                cp,cp
            );
            pathDirty = true;
        },
        bezierCurveTo : function(cp1x,cp1y,cp2x,cp2y,x,y){
            if(!path){
                return;
            }
            cp1x = toNumber(cp1x);
            cp1y = toNumber(cp1y);
            cp2x = toNumber(cp2x);
            cp2y = toNumber(cp2y);
            x = toNumber(x);
            y = toNumber(y);

            path.curveToPoint_(
                NSMakePoint(x,y),
                NSMakePoint(cp1x,cp1y),
                NSMakePoint(cp2x,cp2y)
            );
            pathDirty = true;
        },
        rect : function(x,y,width,height){
            if(!path){
                return;
            }
            appendRect(x,y,width,height);
            pathDirty = true;
        },
        fillRect : function(x,y,width,height){
            beginPath();
            appendRect(x,y,width,height);
            pathDirty = true;
            addPathWithStylePart(false,true);
        },
        strokeRect : function(x,y,width,height){
            beginPath();
            appendRect(x,y,width,height);
            pathDirty = true;
            addPathWithStylePart(true,false);
        },
        arcTo : function(x1,y1,x2,y2,radius){
            if(!path){
                return;
            }
            x1 = toNumber(x1);
            y1 = toNumber(y1);
            x2 = toNumber(x2);
            y2 = toNumber(y2);
            radius = toNumber(radius);

            path.appendBezierPathWithArcFromPoint_toPoint_radius(
                NSMakePoint(x1,y1),
                NSMakePoint(x2,y2),
                radius
            );
            pathDirty = true;
        },
        arc : function(x,y,radius,startAngle,endAngle,anticlockwise){
            if(!path){
                return;
            }
            x = toNumber(x);
            y = toNumber(y);
            radius = toNumber(radius);
            startAngle = toNumber(startAngle);
            endAngle   = toNumber(endAngle);
            anticlockwise = toBoolean(anticlockwise);

            path.appendBezierPathWithArcWithCenter_radius_startAngle_endAngle_clockwise_(
                NSMakePoint(x,y),
                radius,
                toDegrees(startAngle),
                toDegrees(endAngle),
                anticlockwise
            );
            pathDirty = true;
        },
        stroke : function(){
            if(!path){
                return;
            }
            addPathWithStylePart(true,false);
        },
        fill : function(){
            if(!path){
                return;
            }
            addPathWithStylePart(false,true);
        },
        clip : function(args){
            //TODO: Add clip
        },

        /*------------------------------------------------------------------------------------------------------------*/
        // text
        /*------------------------------------------------------------------------------------------------------------*/

        // (default: "10px sans-serif")
        setFont : function(font){
            font = toString(font);
            //TODO: parse font correctly here
            state.font = font;
        },
        getFont : function(){
            return state.font;
        },
        // "start", "end", "left", "right", "center" (default: "start")
        setTextAlign : function(textAlign){
            textAlign = toString(textAlign);
            switch(textAlign){
                case 'start':
                case 'end':
                case 'left':
                case 'right':
                case 'center':
                    state.textAlign = textAlign;
                    break;
                default:
                    WebScriptObject.throwException('Unsupported textAlign "' + textAlign + '"');
            }
        },
        // "top", "hanging", "middle", "alphabetic", "ideographic", "bottom" (default: "alphabetic")
        getTextAlign : function(){
            return state.textAlign
        },
        setTextBaseline : function(textBaseline){
            textBaseline = toString(textBaseline);
            switch(textBaseline){
                case 'top':
                case 'hanging':
                case 'middle':
                case 'alphabetic':
                case 'ideographic':
                    state.textBaseline = textBaseline;
                    break;
                default:
                    WebScriptObject.throwException('Unsupported textBaseline "' + textBaseline + '"');
            }
        },
        getTextBaseline : function(){
            return state.textBaseline;
        },
        fillText : function(args){
            //TODO: Add fillText
        },
        strokeText : function(args){
            //TODO: Add strokeText
        },
        measureText : function(args){
            return {width : 0}
        },

        /*------------------------------------------------------------------------------------------------------------*/
        // draw images
        /*------------------------------------------------------------------------------------------------------------*/

        drawImage : function(args){
            //TODO: Add drawImage
        }
    };

    return ctx;
}

//Executed in js context
function Context2DWrap(){
    //TODO: No rewrapping, extend JSWebScriptingObject convert
    //NOTE: cant retrieve keys, properties, refer webscriptingobj methods
    //So manual wrapping atm.

    var canvas = {
        get width() {return __sketch.artboardWidth();},
        get height(){return __sketch.artboardHeight();}
    };

    var context2d = {
        get canvas(){return canvas;},
        //state
        save :    function(){__bindings.save();},
        restore : function(){__bindings.restore();},
        //clear stub
        clearRect : function(){},

        //transformations
        scale :        function(x,y){__bindings.scale(x,y);},
        rotate :       function(angle){__bindings.rotate(angle);},
        translate :    function(x,y){__bindings.translate(x,y);},
        transform :    function(a,b,c,d,e,f){__bindings.transform(a,b,c,d,e,f);},
        setTransform : function(a,b,c,d,e,f){__bindings.setTransform(a,b,c,d,e,f);},
        //compositing
        set globalAlpha(val){__bindings.setGlobalAlpha(val);},
        get globalAlpha()   {return __bindings.getGlobalAlpha();},
        //colors and styles
        set strokeStyle(val){__bindings.setStrokeStyle(val);},
        get strokeStyle()   {return __bindings.getStrokeStyle();},
        set fillStyle(val)  {__bindings.setFillStyle(val)},
        get fillStyle()     {return __bindings.getFillStyle();},
        //createLinearGradient : ctx.createLinearGradient,
        //createRadialGradient : ctx.createRadialGradient,
        //createPattern : ctx.createPattern,

        //line caps/joins
        set lineWidth(val)     {__bindings.setLineWidth(val);},
        get lineWidth()        {return __bindings.getLineWidth();},
        set lineCap(val)       {__bindings.setLineCap(val);},
        get lineCap()          {return __bindings.getLineCap();},
        set lineJoin(val)      {__bindings.setLineJoin(val);},
        get lineJoin()         {return __bindings.getLineJoin();},
        set miterLimit(val)    {__bindings.setMiterLimit(val);},
        get miterLimit()       {return __bindings.getMiterLimit();},
        setLineDash :          function(val){__bindings.setLineDash(val);},
        getLineDash :          function(){return __bindings.getLineDash();},
        set lineDashOffset(val){__bindings.setLineDashOffset(val);},
        get lineDashOffset()   {return __bindings.getLineDashOffset();},
        //shadows
        set shadowOffsetX(val){__bindings.setShadowOffsetX(val);},
        get shadowOffsetX()   {return __bindings.getShadowOffsetX();},
        set shadowOffsetY(val){__bindings.setShadowOffsetY(val);},
        get shadowOffsetY()   {return __bindings.getShadowOffsetY();},
        set shadowColor(val)  {__bindings.setShadowColor(val);},
        get shadowColor()     {return __bindings.getShadowColor();},
        set shadowBlur(val)   {__bindings.setShadowBlur(val);},
        get shadowBlur()      {return __bindings.getShadowBlur();},
        //path API
        beginPath :        function(){__bindings.beginPath();},
        closePath :        function(){__bindings.closePath();},
        moveTo :           function(x,y){__bindings.moveTo(x,y);},
        lineTo :           function(x,y){__bindings.lineTo(x,y);},
        quadraticCurveTo : function(cpx,cpy,x,y){__bindings.quadraticCurveTo(cpx,cpy,x,y);},
        bezierCurveTo :    function(cp1x,cp1y,cp2x,cp2y,x,y){__bindings.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y);},
        rect :             function(x,y,width,height){__bindings.rect(x,y,width,height);},
        fillRect :         function(x,y,width,height){__bindings.fillRect(x,y,width,height);},
        strokeRect :       function(x,y,width,height){__bindings.strokeRect(x,y,width,height);},
        arcTo :            function(x1,y1,x2,y2,radius){__bindings.arcTo(x1,y1,x2,y2,radius);},
        arc :              function(x,y,radius,startAngle,endAngle,clockwise){__bindings.arc(x,y,radius,startAngle,endAngle,clockwise);},
        stroke :           function(){__bindings.stroke();},
        fill :             function(){__bindings.fill();},
        //isPointInPath : ctx.isPointInPath

        //text
        fillText :        function(text,x,y,maxWidth){__bindings.fillText(text,x,y,maxWidth);},
        strokeText :      function(text,x,y,maxWidth){__bindings.strokeText(text,x,y,maxWidth);},
        measureText :     function(text){return __bindings.measureText(text)},
        set font(val)     {__bindings.setFont(val);},
        get font()        {return __bindings.getFont();},
        set textAlign(val){__bindings.setTextAlign(val);},
        get textAlign()   {return __bindings.getTextAlign();},
        set textBaseline(val){__bindings.setTextBaseline(val);},
        get textBaseline()   {return __bindings.getTextBaseline();},

        //drawing images
        drawImage : function(image,sx,sy,sw,sh,dx,dy,dw,dh){__bindings.drawImage(image,sx,sy,sw,sh,dx,dy,dw,dh);}
    };

    canvas.getContext = function(){return context2d;};
    return canvas;
}